/*
 * 
 * All the help and tools you need to grow online: Websites, Domains, Digital and Social Marketing - plus GoDaddy Guides with you every step of the way.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * DomainDnssec
 */@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class DomainDnssec {
  /**
   * This identifies the cryptographic algorithm used to generate the signature&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSAMD5&lt;/strong&gt; - [01] DRSA/MD5 &lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;DSA&lt;/strong&gt; - [03] DSA/SHA1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSASHA1&lt;/strong&gt; - [05] RSA/SHA-1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;DSA_NSEC3_SHA1&lt;/strong&gt; - [06] DSA-NSEC3-SHA1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSASHA1_NSEC3_SHA1&lt;/strong&gt; - [07] RSASHA1-NSEC3-SHA1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSASHA256&lt;/strong&gt; - [08] RSA/SHA-256&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSASHA512&lt;/strong&gt; - [10] RSA/SHA-512&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ECC_GOST&lt;/strong&gt; - [12] GOST R 34.10-2001&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ECDSAP256SHA256&lt;/strong&gt; - [13] ECDSA Curve P-256 with SHA-256&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ECDSAP384SHA384&lt;/strong&gt; - [14] ECDSA Curve P-384 with SHA-384&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ED25519&lt;/strong&gt; - [15] Ed25519&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ED448&lt;/strong&gt; - [16] Ed448&lt;/li&gt;&lt;/ul&gt;
   */
  @JsonAdapter(AlgorithmEnum.Adapter.class)
 public enum AlgorithmEnum {
    RSAMD5("RSAMD5"),
    
    DH("DH"),
    
    DSA("DSA"),
    
    RSASHA1("RSASHA1"),
    
    DSA_NSEC3_SHA1("DSA_NSEC3_SHA1"),
    
    RSASHA1_NSEC3_SHA1("RSASHA1_NSEC3_SHA1"),
    
    RSASHA256("RSASHA256"),
    
    RSASHA512("RSASHA512"),
    
    ECC_GOST("ECC_GOST"),
    
    ECDSAP256SHA256("ECDSAP256SHA256"),
    
    ECDSAP384SHA384("ECDSAP384SHA384"),
    
    ED25519("ED25519"),
    
    ED448("ED448"),
    
    PRIVATEDNS("PRIVATEDNS"),
    
    PRIVATEOID("PRIVATEOID");

    private String value;

    AlgorithmEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AlgorithmEnum fromValue(String value) {
      for (AlgorithmEnum b : AlgorithmEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AlgorithmEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AlgorithmEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AlgorithmEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AlgorithmEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_ALGORITHM = "algorithm";
  @SerializedName(SERIALIZED_NAME_ALGORITHM)
  private AlgorithmEnum algorithm;

  public static final String SERIALIZED_NAME_DIGEST = "digest";
  @SerializedName(SERIALIZED_NAME_DIGEST)
  private String digest;

  /**
   * This identifies the algorithm used to construct the digest&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;SHA1&lt;/strong&gt; - [01] SHA-1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;SHA256&lt;/strong&gt; - [02] SHA-256&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;GOST&lt;/strong&gt; - [03] GOST R 34.11-94&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;SHA384&lt;/strong&gt; - [04] SHA-384&lt;/li&gt;&lt;/ul&gt;
   */
  @JsonAdapter(DigestTypeEnum.Adapter.class)
 public enum DigestTypeEnum {
    SHA1("SHA1"),
    
    SHA256("SHA256"),
    
    GOST("GOST"),
    
    SHA384("SHA384");

    private String value;

    DigestTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DigestTypeEnum fromValue(String value) {
      for (DigestTypeEnum b : DigestTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DigestTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DigestTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DigestTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DigestTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_DIGEST_TYPE = "digestType";
  @SerializedName(SERIALIZED_NAME_DIGEST_TYPE)
  private DigestTypeEnum digestType;

  /**
   * This identifies the key type; either a Zone-Signing Key or a Key-Signing Key&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ZSK&lt;/strong&gt; - [256] Zone-Signing Key&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;KSK&lt;/strong&gt; - [257] Key-Signing Key&lt;/li&gt;&lt;/ul&gt;
   */
  @JsonAdapter(FlagsEnum.Adapter.class)
 public enum FlagsEnum {
    ZSK("ZSK"),
    
    KSK("KSK");

    private String value;

    FlagsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FlagsEnum fromValue(String value) {
      for (FlagsEnum b : FlagsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FlagsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FlagsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FlagsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FlagsEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_FLAGS = "flags";
  @SerializedName(SERIALIZED_NAME_FLAGS)
  private FlagsEnum flags;

  public static final String SERIALIZED_NAME_KEY_TAG = "keyTag";
  @SerializedName(SERIALIZED_NAME_KEY_TAG)
  private Integer keyTag;

  public static final String SERIALIZED_NAME_MAX_SIGNATURE_LIFE = "maxSignatureLife";
  @SerializedName(SERIALIZED_NAME_MAX_SIGNATURE_LIFE)
  private Integer maxSignatureLife;

  public static final String SERIALIZED_NAME_PUBLIC_KEY = "publicKey";
  @SerializedName(SERIALIZED_NAME_PUBLIC_KEY)
  private String publicKey;

  public DomainDnssec() {
  }

  public DomainDnssec algorithm(AlgorithmEnum algorithm) {
    
    
    
    
    this.algorithm = algorithm;
    return this;
  }

   /**
   * This identifies the cryptographic algorithm used to generate the signature&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSAMD5&lt;/strong&gt; - [01] DRSA/MD5 &lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;DSA&lt;/strong&gt; - [03] DSA/SHA1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSASHA1&lt;/strong&gt; - [05] RSA/SHA-1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;DSA_NSEC3_SHA1&lt;/strong&gt; - [06] DSA-NSEC3-SHA1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSASHA1_NSEC3_SHA1&lt;/strong&gt; - [07] RSASHA1-NSEC3-SHA1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSASHA256&lt;/strong&gt; - [08] RSA/SHA-256&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;RSASHA512&lt;/strong&gt; - [10] RSA/SHA-512&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ECC_GOST&lt;/strong&gt; - [12] GOST R 34.10-2001&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ECDSAP256SHA256&lt;/strong&gt; - [13] ECDSA Curve P-256 with SHA-256&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ECDSAP384SHA384&lt;/strong&gt; - [14] ECDSA Curve P-384 with SHA-384&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ED25519&lt;/strong&gt; - [15] Ed25519&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ED448&lt;/strong&gt; - [16] Ed448&lt;/li&gt;&lt;/ul&gt;
   * @return algorithm
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "This identifies the cryptographic algorithm used to generate the signature<br/><ul><li><strong style='margin-left: 12px;'>RSAMD5</strong> - [01] DRSA/MD5 </li><li><strong style='margin-left: 12px;'>DSA</strong> - [03] DSA/SHA1</li><li><strong style='margin-left: 12px;'>RSASHA1</strong> - [05] RSA/SHA-1</li><li><strong style='margin-left: 12px;'>DSA_NSEC3_SHA1</strong> - [06] DSA-NSEC3-SHA1</li><li><strong style='margin-left: 12px;'>RSASHA1_NSEC3_SHA1</strong> - [07] RSASHA1-NSEC3-SHA1</li><li><strong style='margin-left: 12px;'>RSASHA256</strong> - [08] RSA/SHA-256</li><li><strong style='margin-left: 12px;'>RSASHA512</strong> - [10] RSA/SHA-512</li><li><strong style='margin-left: 12px;'>ECC_GOST</strong> - [12] GOST R 34.10-2001</li><li><strong style='margin-left: 12px;'>ECDSAP256SHA256</strong> - [13] ECDSA Curve P-256 with SHA-256</li><li><strong style='margin-left: 12px;'>ECDSAP384SHA384</strong> - [14] ECDSA Curve P-384 with SHA-384</li><li><strong style='margin-left: 12px;'>ED25519</strong> - [15] Ed25519</li><li><strong style='margin-left: 12px;'>ED448</strong> - [16] Ed448</li></ul>")

  public AlgorithmEnum getAlgorithm() {
    return algorithm;
  }


  public void setAlgorithm(AlgorithmEnum algorithm) {
    
    
    
    this.algorithm = algorithm;
  }


  public DomainDnssec digest(String digest) {
    
    
    
    
    this.digest = digest;
    return this;
  }

   /**
   * The digest is an alpha-numeric value
   * @return digest
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The digest is an alpha-numeric value")

  public String getDigest() {
    return digest;
  }


  public void setDigest(String digest) {
    
    
    
    this.digest = digest;
  }


  public DomainDnssec digestType(DigestTypeEnum digestType) {
    
    
    
    
    this.digestType = digestType;
    return this;
  }

   /**
   * This identifies the algorithm used to construct the digest&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;SHA1&lt;/strong&gt; - [01] SHA-1&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;SHA256&lt;/strong&gt; - [02] SHA-256&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;GOST&lt;/strong&gt; - [03] GOST R 34.11-94&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;SHA384&lt;/strong&gt; - [04] SHA-384&lt;/li&gt;&lt;/ul&gt;
   * @return digestType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "This identifies the algorithm used to construct the digest<br/><ul><li><strong style='margin-left: 12px;'>SHA1</strong> - [01] SHA-1</li><li><strong style='margin-left: 12px;'>SHA256</strong> - [02] SHA-256</li><li><strong style='margin-left: 12px;'>GOST</strong> - [03] GOST R 34.11-94</li><li><strong style='margin-left: 12px;'>SHA384</strong> - [04] SHA-384</li></ul>")

  public DigestTypeEnum getDigestType() {
    return digestType;
  }


  public void setDigestType(DigestTypeEnum digestType) {
    
    
    
    this.digestType = digestType;
  }


  public DomainDnssec flags(FlagsEnum flags) {
    
    
    
    
    this.flags = flags;
    return this;
  }

   /**
   * This identifies the key type; either a Zone-Signing Key or a Key-Signing Key&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;ZSK&lt;/strong&gt; - [256] Zone-Signing Key&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;&#39;margin-left: 12px;&#39;&gt;KSK&lt;/strong&gt; - [257] Key-Signing Key&lt;/li&gt;&lt;/ul&gt;
   * @return flags
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "This identifies the key type; either a Zone-Signing Key or a Key-Signing Key<br/><ul><li><strong style='margin-left: 12px;'>ZSK</strong> - [256] Zone-Signing Key</li><li><strong style='margin-left: 12px;'>KSK</strong> - [257] Key-Signing Key</li></ul>")

  public FlagsEnum getFlags() {
    return flags;
  }


  public void setFlags(FlagsEnum flags) {
    
    
    
    this.flags = flags;
  }


  public DomainDnssec keyTag(Integer keyTag) {
    
    if (keyTag != null && keyTag > 65536) {
      throw new IllegalArgumentException("Invalid value for keyTag. Must be less than or equal to 65536.");
    }
    
    
    this.keyTag = keyTag;
    return this;
  }

   /**
   * This is an integer value less than 65536 used to identify the DNSSEC record for the domain name.
   * maximum: 65536
   * @return keyTag
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "This is an integer value less than 65536 used to identify the DNSSEC record for the domain name.")

  public Integer getKeyTag() {
    return keyTag;
  }


  public void setKeyTag(Integer keyTag) {
    
    if (keyTag != null && keyTag > 65536) {
      throw new IllegalArgumentException("Invalid value for keyTag. Must be less than or equal to 65536.");
    }
    
    this.keyTag = keyTag;
  }


  public DomainDnssec maxSignatureLife(Integer maxSignatureLife) {
    
    
    
    
    this.maxSignatureLife = maxSignatureLife;
    return this;
  }

   /**
   * This specifies the validity period for the signature. The value is expressed in seconds. You can use any integer value larger than zero
   * @return maxSignatureLife
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "This specifies the validity period for the signature. The value is expressed in seconds. You can use any integer value larger than zero")

  public Integer getMaxSignatureLife() {
    return maxSignatureLife;
  }


  public void setMaxSignatureLife(Integer maxSignatureLife) {
    
    
    
    this.maxSignatureLife = maxSignatureLife;
  }


  public DomainDnssec publicKey(String publicKey) {
    
    
    
    
    this.publicKey = publicKey;
    return this;
  }

   /**
   * Registries use this value to encrypt DS records. Decryption requires a matching public key
   * @return publicKey
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Registries use this value to encrypt DS records. Decryption requires a matching public key")

  public String getPublicKey() {
    return publicKey;
  }


  public void setPublicKey(String publicKey) {
    
    
    
    this.publicKey = publicKey;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the DomainDnssec instance itself
   */
  public DomainDnssec putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DomainDnssec domainDnssec = (DomainDnssec) o;
    return Objects.equals(this.algorithm, domainDnssec.algorithm) &&
        Objects.equals(this.digest, domainDnssec.digest) &&
        Objects.equals(this.digestType, domainDnssec.digestType) &&
        Objects.equals(this.flags, domainDnssec.flags) &&
        Objects.equals(this.keyTag, domainDnssec.keyTag) &&
        Objects.equals(this.maxSignatureLife, domainDnssec.maxSignatureLife) &&
        Objects.equals(this.publicKey, domainDnssec.publicKey)&&
        Objects.equals(this.additionalProperties, domainDnssec.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(algorithm, digest, digestType, flags, keyTag, maxSignatureLife, publicKey, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DomainDnssec {\n");
    sb.append("    algorithm: ").append(toIndentedString(algorithm)).append("\n");
    sb.append("    digest: ").append(toIndentedString(digest)).append("\n");
    sb.append("    digestType: ").append(toIndentedString(digestType)).append("\n");
    sb.append("    flags: ").append(toIndentedString(flags)).append("\n");
    sb.append("    keyTag: ").append(toIndentedString(keyTag)).append("\n");
    sb.append("    maxSignatureLife: ").append(toIndentedString(maxSignatureLife)).append("\n");
    sb.append("    publicKey: ").append(toIndentedString(publicKey)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("algorithm");
    openapiFields.add("digest");
    openapiFields.add("digestType");
    openapiFields.add("flags");
    openapiFields.add("keyTag");
    openapiFields.add("maxSignatureLife");
    openapiFields.add("publicKey");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("algorithm");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DomainDnssec
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DomainDnssec.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DomainDnssec is not found in the empty JSON string", DomainDnssec.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DomainDnssec.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("algorithm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `algorithm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("algorithm").toString()));
      }
      if ((jsonObj.get("digest") != null && !jsonObj.get("digest").isJsonNull()) && !jsonObj.get("digest").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `digest` to be a primitive type in the JSON string but got `%s`", jsonObj.get("digest").toString()));
      }
      if ((jsonObj.get("digestType") != null && !jsonObj.get("digestType").isJsonNull()) && !jsonObj.get("digestType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `digestType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("digestType").toString()));
      }
      if ((jsonObj.get("flags") != null && !jsonObj.get("flags").isJsonNull()) && !jsonObj.get("flags").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `flags` to be a primitive type in the JSON string but got `%s`", jsonObj.get("flags").toString()));
      }
      if ((jsonObj.get("publicKey") != null && !jsonObj.get("publicKey").isJsonNull()) && !jsonObj.get("publicKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publicKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publicKey").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DomainDnssec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DomainDnssec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DomainDnssec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DomainDnssec.class));

       return (TypeAdapter<T>) new TypeAdapter<DomainDnssec>() {
           @Override
           public void write(JsonWriter out, DomainDnssec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public DomainDnssec read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             DomainDnssec instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DomainDnssec given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DomainDnssec
  * @throws IOException if the JSON string is invalid with respect to DomainDnssec
  */
  public static DomainDnssec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DomainDnssec.class);
  }

 /**
  * Convert an instance of DomainDnssec to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

